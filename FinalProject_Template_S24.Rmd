---
title: 'MATH 324 Final Project'
author: "Nathan Howland, Madilyn Webb, Ellise Putnam, Addison Hart"
output:
  pdf_document: default
  html_notebook: default
---

  
```{r, include=F, warning=F, message=F}
# front-matter
rm(list = ls()) # clear the workspace

library(Stat2Data)
library(tidyverse)
library(mosaic)
library(ggformula)
library(emmeans)
library(scales)
library(leaps)
library(dplyr)
library(HH)
library(vcdExtra)


knitr::opts_chunk$set(echo = F)
```

```{r, include = F}
# weather <- read.csv("/Users/nathanhowland/Documents/324_Final_Project/weatherAUS.csv", header = TRUE)
weather <- read.csv("./weatherAUS.csv", header = TRUE)
compute_brier <- function(actual, predicted) {
  mean((actual - predicted)^2)
}
```



# 1. Project Description

This experiment is using a data set of the weather patterns across various cities in Australia, which contains variables such as the humidity, pressure, cloud coverage, temperature, and much more. This experiment was conducted as an observational study, where the goal of the study was to predict the possibility of rain based on these variables. We wanted to determine:
1) Whether additional weather variables led to a sufficiently improved model for predicting rainfall in Australia
2) Whether there are different variables that conclude better predictions based on the city within Australia

## 1.1 Research Questions

**Research Question 1:**  What model should we use to predict rainfall across Australia? We want to discover which variables are the most reliable predictors of the rainfall for the "Next day".

**Research Question 2:**  Should we use different models for different locations? Are there models that are better suited for different locations across Australia, and what variables are the best for these locations?

## 1.2 Variables

*What is (are) possible explanatory and response variables?*

*Create a table here - it should include variable names and types*

|    Variable   |    Type    | E/R |
|:-------------:|:----------:|:---:|
| Location      |Categorical |  E  |
| MinTemp       |Quantitative|  E  |
| MaxTemp       |Quantitative|  E  |
| Rainfall      |Quantitative|  E  |
| Evaporation   |Quantitative|  E  |
| Sunshine      |Quantitative|  E  |
| WindGustDir   |Categorical |  E  |
| WindGustSpeed |Quantitative|  E  |
| WindDir9am    |Categorical |  E  |
| WindDir3pm    |Categorical |  E  |
| WindSpeed9am  |Quantitative|  E  |
| WindSpeed3pm  |Quantitative|  E  |
| Humidity9am   |Quantitative|  E  |
| Humidity3pm   |Quantitative|  E  |
| Pressure9am   |Quantitative|  E  |
| Pressure3pm   |Quantitative|  E  |
| Cloud9am      |Categorical |  E  |
| Cloud3pm      |Categorical |  E  |
| Temp9am       |Quantitative|  E  |
| Temp3pm       |Quantitative|  E  |
| RainToday     |  Boolean   |  E  |
| RainTomorrow  |  Boolean   |  R  |

#  2. Detailed Exploratory Data Analysis (EDA)

### Question 1: Simple logistic regression model using RainToday as a predictor

```{r}
# clean data
clean_weather <- weather %>% na.omit()

# model
lr_model <- glm(RainTomorrow ~ RainToday, family = binomial(link = "logit"), data = clean_weather)

ggplot(clean_weather, aes(x = RainToday, fill = RainTomorrow)) +
  geom_bar(position = "fill") +
  ylab("Proportion") +
  ggtitle("Proportion of Rain Tomorrow by Rain Today")
```

<br>

```{r}
mosaic(~ RainToday + RainTomorrow, data = clean_weather, shade = TRUE, legend = TRUE)
```

<br>

```{r}
emplogitplot1(as.numeric(RainTomorrow) ~ as.numeric(RainToday), data = clean_weather, ngroups = "all")
```

### Question 2: Best model (using BIC) of all locations

```{r}
# clean data
clean_weather2 <- clean_weather
clean_weather2$Location <- factor(clean_weather2$Location)

# adding indicators
clean_weather2$IndLoc <- ifelse(clean_weather2$Location == "Sydney", 1, 0)
clean_weather2$IndWindGustDir <- ifelse(clean_weather2$WindGustDir == "W", 1, 0)
clean_weather2$IndWindDir9am <- ifelse(clean_weather2$WindDir9am == "W", 1, 0)
clean_weather2$IndWindDir3pm <- ifelse(clean_weather2$WindDir3pm == "WNW", 1, 0)

# performing stepwise and creating BIC
none <- lm(RainTomorrow ~ 1, data = clean_weather2)
full_model <- lm(RainTomorrow ~ ., data = clean_weather2)

# step(none, scope = list(upper = full_model), direction = "forward", really.big = T)

all <- regsubsets(RainTomorrow ~ . - Location - WindGustDir - WindDir9am - WindDir3pm, data = clean_weather2, nbest = 1, really.big = TRUE)
plot(all, scale = "bic")
```

After performing a stepwise function for all variables, it was concluded from solely the BIC table that the most effective variables for predicting RainTomorrow was Sunshine + WindGustSpeed + WindSpeed3pm + Humidity3pm + Pressure3pm + RainToday.  Additionally, when creating the BIC table, some additional cleanup was performed where we created Indicator varaibles for some of the categorical variables such as IndLoc, IndWindGustDir, IndWindDir9am and IndWindDir3pm.  Using our BIC table we created a model using these variables, as seen below.

```{r}
summaryHH(all)

# create model based on BIC
myModel <- glm(RainTomorrow ~ Sunshine + WindGustSpeed + WindSpeed3pm + Humidity3pm + Pressure3pm + RainToday, family = "binomial", data = clean_weather2)
summary(myModel)
```

As demonstrated from the following model, all variables prove to be significant predictors of RainTomorrow as all p-values are less than our significance level of 0.05.  Additionally, we have an AIC value of 38,540 which is the lowest value we could attain for predicting RainTomorrow.  For some context, when all other predictors are zero, the log odds of RainTomorrow is 74.50.  Additionally, for each unit increase in sunshine, the log odds of RainTomorrow decrease by 0.168.  This interpretation of variables also apply meaning that, for example, if it rained today (RainTodayTRUE), the log odds of RainTomorrow increase by 0.389 compared to when it didn't rain today.

$\hat{\text{rainTomorrow}} = 74.4980470 + -0.1679587 * \text{Sunshine}  + 0.0508944 * \text{WindGustSpeed} - 0.0330498 * \text{WindSpeed3pm} + 0.0533006 * \text{Humidity3pm} - 0.0781103 * \text{Pressure3pm} + 0.3888131 * \text{RainTodayTRUE} $

```{r}
# plot model
emplogitplot1(RainTomorrow ~ Sunshine + WindGustSpeed + WindSpeed3pm + Humidity3pm + Pressure3pm + RainToday, data = clean_weather2, ngroups = "all")

predicted <- predict(myModel, newdata = clean_weather2, type = "response")
```

As a result of our predictive model, we created a empirical logit plot to verify whether the relationships between Sunshine + WindGustSpeed + WindSpeed3pm + Humidity3pm + Pressure3pm + RainToday and RainTomorrow align with our expectations to assess the overall goodness of fit of your logistic regression model.  Given the plot demonstrates data points that reasonably fall along the blue line, we can conclude that our model effectively demonstrates the  relationship between our predictors and the RainTomorrow.

### Question 3: Simple Logistic regression model dependent on the location

```{r}
cleanWeather3 <- weather %>% na.omit()
SydneyWeather <- cleanWeather3 %>% filter(Location == "Sydney")
MelbourneWeather <- cleanWeather3 %>% filter(Location == "Melbourne")

gf_bar(~ RainToday | Location, data = SydneyWeather, fill = ~RainTomorrow, position = position_dodge())
gf_bar(~ RainToday | Location, data = MelbourneWeather, fill = ~RainTomorrow, position = position_dodge())

model_sydney <- glm(RainTomorrow ~ RainToday, family = binomial(link = "logit"), data = SydneyWeather)
model_melbourne <- glm(RainTomorrow ~ RainToday, family = binomial(link = "logit"), data = MelbourneWeather)
summary(model_sydney)
summary(model_melbourne)

emplogitplot1(as.numeric(RainTomorrow) ~ as.numeric(RainToday), data = SydneyWeather, ngroups = "all")
emplogitplot1(as.numeric(RainTomorrow) ~ as.numeric(RainToday), data = MelbourneWeather, ngroups = "all")
```

### Question 4: Best model (using BIC) of two locations

```{r}
# Data cleaning
weather_cleaned_sydney <- weather %>%
  dplyr::select(-c(WindGustDir, WindDir9am, WindDir3pm)) %>%
  na.omit() %>%
  filter(Location == "Sydney") %>%
  dplyr::select(-c(Location))
weather_cleaned_melbourne <- weather %>%
  dplyr::select(-c(WindGustDir, WindDir9am, WindDir3pm)) %>%
  na.omit() %>%
  filter(Location == "Melbourne") %>%
  dplyr::select(-c(Location))

# BIC plot Sydney
all_sydney <- regsubsets(RainTomorrow ~ ., data = weather_cleaned_sydney, method = "exhaustive")
plot(all_sydney, scale = "bic")
summaryHH(all_sydney)
rain_tomorrow_sydney_model <- glm(RainTomorrow ~ MinTemp + MaxTemp + Sunshine + WindGustSpeed + Humidity3pm + RainToday, data = weather_cleaned_sydney)
```

<br>

```{r}
# Linearity odds plot Sydney
emplogitplot1(RainTomorrow ~ Sunshine + MinTemp + MaxTemp + WindGustSpeed + Humidity3pm + RainToday, data = weather_cleaned_sydney, ngroups = "all")

# cor(weather_cleaned_sydney)

# BIC plot Melbourne
all_melbourne <- regsubsets(RainTomorrow ~ ., data = weather_cleaned_melbourne, method = "exhaustive")
plot(all_melbourne, scale = "bic")
summaryHH(all_melbourne)
rain_tomorrow_melbourne_model <- glm(RainTomorrow ~ MinTemp + MaxTemp + Sunshine + WindGustSpeed + Humidity3pm + RainToday, data = weather_cleaned_melbourne)
```

<br>

```{r}
# Linearity odds plot Melbourne
emplogitplot1(RainTomorrow ~ Sunshine + MinTemp + MaxTemp + WindGustSpeed + Humidity3pm + RainToday, data = weather_cleaned_melbourne, ngroups = "all")

# cor(weather_cleaned_melbourne)
```

A BIC plot is made of both data from Sydney and data from Melbourne to derive the explanatory variables that maximize the BIC score, which we then use to create a simple logistic model. A linearity condition assesment using the logarithm of the odds is also employed.

*Spend time investigating the data thoroughly and use this section to present figures that allow you to visualize the relationship of the response to different predictors.  Include descriptions of the figures that illustrate what you can learn from them.*

# 3. Statistical Analysis 

**Research Question 1**

*Describe the statistical analysis that you used to answer both research questions. Each analysis should be labeled for the appropriate research question. This section should summarize all relevant analyses that lead to your final conclusions/decisions/recommendations. Be sure to include:*

- *Model Assumptions & how checked/verified*
- *Interpretation of relevant estimates/statistics/p-values IN CONTEXT*

### Question 1: Simple logistic regression model using RainToday as a predictor

```{r}
# Brier scores
print(paste("Brier score:", compute_brier(clean_weather$RainTomorrow, predict(lr_model, clean_weather, type = "response"))))

pi_rainToday <- exp(-1.720027 + 1.576018) / (1 + exp(-1.720027 + 1.576018))
odds_rainToday <- pi_rainToday / (1 - pi_rainToday)
pi_not_rainToday <- exp(-1.720027) / (1 + exp(-1.720027))
odds_not_rainToday <- pi_not_rainToday / (1 - pi_not_rainToday)
print(paste("Odds Ratio:", odds_rainToday / odds_not_rainToday))
```

### Question 2: Best model (using BIC) of all locations

```{r}
# Brier scores
print(paste("Brier score:", compute_brier(clean_weather2$RainTomorrow, predict(myModel, clean_weather2, type = "response"))))
```

Given our brier score of 0.1066608 which indicates that, on average, the squared difference between the predicted probabilities of rain tomorrow and the actual outcomes is 0.1066608. Overall, our score of 0.1066608 indicates that our model is making accurate predictions of rain tomorrow, which is a positive indication of its performance.

### Question 3: Simple Logistic regression model dependent on the location

```{r}
# Brier scores
print(paste("Brier score for Sydney:", compute_brier(SydneyWeather$RainTomorrow, predict(model_sydney, SydneyWeather, type = "response"))))
print(paste("Brier score for Melbourne:", compute_brier(MelbourneWeather$RainTomorrow, predict(model_melbourne, MelbourneWeather, type = "response"))))

pi_sydney_rainToday <- exp(-1.58290 + 1.62910) / (1 + exp(-1.58290 + 1.62910))
pi_sydney_not_rainToday <- exp(-1.58290) / (1 + exp(-1.58290))

odds_sydney_rainToday <- pi_sydney_rainToday / (1 - pi_sydney_rainToday)
odds_sydney_not_rainToday <- pi_sydney_not_rainToday / (1 - pi_sydney_not_rainToday)

print(paste("Odds Ratio for Sydney:", odds_sydney_rainToday / odds_sydney_not_rainToday))

pi_melbourne_rainToday <- exp(-1.50550 + 1.02034) / (1 + exp(-1.50550 + 1.02034))
pi_melbourne_not_rainToday <- exp(-1.50550) / (1 + exp(-1.50550))

odds_melbourne_rainToday <- pi_melbourne_rainToday / (1 - pi_melbourne_rainToday)
odds_melbourne_not_rainToday <- pi_melbourne_not_rainToday / (1 - pi_melbourne_not_rainToday)

print(paste("Odds Ratio for Melbourne:", odds_melbourne_rainToday / odds_melbourne_not_rainToday))
```

### Question 4: Best model (using BIC) of two locations

```{r}
# Brier scores
print(paste("Brier score for Sydney:", compute_brier(weather_cleaned_sydney$RainTomorrow, predict(rain_tomorrow_sydney_model, weather_cleaned_sydney, type = "response"))))
print(paste("Brier score for Melbourne:", compute_brier(weather_cleaned_melbourne$RainTomorrow, predict(rain_tomorrow_melbourne_model, weather_cleaned_melbourne, type = "response"))))
```

*You should not include your code. However, I would like to see the code for final models that you are using to answer the research question in the appendix.* 

## Simple logistic regression model using RainToday as a predictor
## Simple Logistic regression model dependent on the location

The model assumptions we need to satisfy for these two models are:

* Linearity: We cannot prove this assumption because a model using only one categorical boolean variable is not a line. This model essentially uses the number of datapoints having rain yesterday in order to determine a value for rain today.
* Independence: The datapoints were obtained from a sensor whose results are not dependent on yesterday's results, so they are independent.
* Randomness: The datapoints are always recorded from a sensor located in the same geographical location. For example, datapoints from the Sydney Airport are always recorded near the airport. That means that there is no randomness of recordings in the general area indicated by the datapoint. We cannot, therefore, generalize to the entire city.

## What model should we use to predict rainfall across Australia?
## Best model (using BIC) of two locations and the best model (using BIC) of all locations

The model assumptions we need to satisfy for these two models are:

* Linearity: We satisfied this requirement using an Empirical Logit plot, which tests linearity for categorical variables. The best model for all locations is somewhat convex, which could suggest this assumption is not true. The best model for two locations is completely linear, however.
* Independence: The datapoints were obtained from a sensor whose results are not dependent on yesterday's results, so they are independent.
* Randomness: The datapoints are always recorded from a sensor located in the same geographical location. For example, datapoints from the Sydney Airport are always recorded near the airport. That means that there is no randomness of recordings in the general area indicated by the datapoint. We cannot, therefore, generalize to the entire city.



# 4. Conclusions 

*Succinct response to each question laid out in 1.1.  This a much shorter version of section 3, and focuses on conclusions rather than the analyses.*

**Research Question 1:**  

**Research Question 2:**  

*(all research questions in 1.1 should be addressed, in the same order)*

# 5. Appendix 

Question 1 Code
__________________________________________________________________________________________________________________________________________________
```r
# clean data
clean_weather <- weather %>% na.omit()

# model
lr_model <- glm(RainTomorrow ~ RainToday, family = binomial(link = "logit"), data = clean_weather)

# eda
ggplot(clean_weather, aes(x = RainToday, fill = RainTomorrow)) +
  geom_bar(position = "fill") +
  ylab("Proportion") +
  ggtitle("Proportion of Rain Tomorrow by Rain Today")

mosaic(~ RainToday + RainTomorrow, data = clean_weather, shade = TRUE, legend = TRUE)
```

<br>

```r
emplogitplot1(as.numeric(RainTomorrow) ~ as.numeric(RainToday), data = clean_weather, ngroups = "all")

# Brier Score
prediction <- predict(lr_model, clean_weather, type = "response")
BriarScore <- mean((prediction - clean_weather$RainTomorrow)^2)

# Odds Ratio
pi_rainToday <- exp(-1.720027 + 1.576018) / (1 + exp(-1.720027 + 1.576018))
odds_rainToday <- pi_rainToday / (1 - pi_rainToday)
pi_not_rainToday <- exp(-1.720027) / (1 + exp(-1.720027))
odds_not_rainToday <- pi_not_rainToday / (1 - pi_not_rainToday)
```

Question 2 Code
__________________________________________________________________________________________________________________________________________________
```r
# clean data
clean_weather2 <- clean_weather
clean_weather2$Location <- factor(clean_weather2$Location)

# adding indicators
clean_weather$IndLoc <- ifelse(clean_weather$Location == "Sydney", 1, 0)
clean_weather$IndWindGustDir <- ifelse(clean_weather$WindGustDir == "W", 1, 0)
clean_weather$IndWindDir9am <- ifelse(clean_weather$WindDir9am == "W", 1, 0)
clean_weather$IndWindDir3pm <- ifelse(clean_weather$WindDir3pm == "WNW", 1, 0)

# performing stepwise and creating BIC
none <- lm(RainTomorrow ~ 1, data = clean_weather)
full_model <- lm(RainTomorrow ~ ., data = clean_weather)

step(none, scope = list(upper = full_model), direction = "forward", really.big = T)

all <- regsubsets(RainTomorrow ~ . - Location - WindGustDir - WindDir9am - WindDir3pm, data = clean_weather, nbest = 1, really.big = TRUE)
plot(all, scale = "bic")

summaryHH(all)

# create model based on BIC
myModel <- glm(RainTomorrow ~ Sunshine + WindGustSpeed + WindSpeed3pm + Humidity3pm + Pressure3pm + RainToday, family = "binomial", data = clean_weather)
summary(myModel)

# plot model
emplogitplot1(RainTomorrow ~ Sunshine + WindGustSpeed + WindSpeed3pm + Humidity3pm + Pressure3pm + RainToday, data = clean_weather, ngroups = "all")

predicted <- predict(myModel, newdata = clean_weather, type = "response")


brier_score <- compute_brier(clean_weather$RainTomorrow, predicted)
brier_score
```

Question 3 Code
__________________________________________________________________________________________________________________________________________________
```r
cleanWeather3 <- weather %>% na.omit()
SydneyWeather <- cleanWeather3 %>% filter(Location == "Sydney")
MelbourneWeather <- cleanWeather3 %>% filter(Location == "Melbourne")

gf_bar(~ RainToday | Location, data = SydneyWeather, fill = ~RainTomorrow, position = position_dodge())
gf_bar(~ RainToday | Location, data = MelbourneWeather, fill = ~RainTomorrow, position = position_dodge())

model_sydney <- glm(RainTomorrow ~ RainToday, family = binomial(link = "logit"), data = SydneyWeather)
model_melbourne <- glm(RainTomorrow ~ RainToday, family = binomial(link = "logit"), data = MelbourneWeather)
summary(model_sydney)
summary(model_melbourne)

plot(model_sydney, which = 1)
plot(model_melbourne, which = 1)
emplogitplot1(as.numeric(RainTomorrow) ~ as.numeric(RainToday), data = SydneyWeather, ngroups = "all")
emplogitplot1(as.numeric(RainTomorrow) ~ as.numeric(RainToday), data = MelbourneWeather, ngroups = "all")

# Make predictions for Sydney
predictions_sydney <- predict(model_sydney, newdata = SydneyWeather, type = "response")

# Make predictions for Melbourne
predictions_melbourne <- predict(model_melbourne, newdata = MelbourneWeather, type = "response")

# Compute Brier scores for Sydney
brier_score_sydney <- compute_brier(SydneyWeather$RainTomorrow, predictions_sydney)
brier_score_sydney

# Compute Brier scores for Melbourne
brier_score_melbourne <- compute_brier(MelbourneWeather$RainTomorrow, predictions_melbourne)
brier_score_melbourne

# Calculate odds ratios
pi_sydney <- exp(-1.58290 + 1.62910) / (1 + exp(-1.58290 + 1.62910))
odds_sydney <- pi_sydney / (1 - pi_sydney)
odds_sydney

pi_melbourne <- exp(-1.50550 + 1.02034) / (1 + exp(-1.50550 + 1.02034))
odds_melbourne <- pi_melbourne / (1 - pi_melbourne)
odds_melbourne
```

Question 4 Code
__________________________________________________________________________________________________________________________________________________


*This section should include the code for the linear models used to answer the research questions, as well as code for any comparisons you are making. *